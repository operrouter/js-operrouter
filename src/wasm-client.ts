/**
 * WASM Client for OperRouter
 * 
 * Uses operrouter-core-wasm bridge for browser-native execution
 * No proxy required - runs entirely in the browser!
 * 
 * Note: WASM module still calls HTTP backend for DataSource/LLM operations.
 * For truly local execution, see rust-operrouter SDK with native Rust runtime.
 */

import type {
  OperRouterClient,
  ClientOptions,
  PingResponse,
  ConfigResponse,
  Metadata,
  DataSourceConfig,
  DataSourceResponse,
  DataSourceQueryResponse,
  LLMConfig,
  LLMResponse,
  LLMGenerateResponse,
  LLMChatResponse,
  LLMEmbeddingResponse,
  ChatMessage,
} from './types.js';

// WASM module interface (generated by wasm-bindgen)
interface WasmModule {
  version: () => string;
  ping: () => string;
  validate_config: (toml: string) => boolean;
  parse_config: (toml: string) => string;
  get_metadata: (toml: string) => string;
  set_http_endpoint: (url: string) => void;
  get_http_endpoint: () => string | undefined;
  ds_create: (name: string, config: any) => Promise<any>;
  ds_query: (name: string, query: string) => Promise<any>;
  ds_execute: (name: string, query: string) => Promise<any>;
  ds_insert: (name: string, data: any) => Promise<any>;
  ds_ping: (name: string) => Promise<any>;
  ds_close: (name: string) => Promise<any>;
  llm_create: (name: string, config: any) => Promise<any>;
  llm_generate: (name: string, prompt: string) => Promise<any>;
  llm_chat: (name: string, messages: any) => Promise<any>;
  llm_embedding: (name: string, text: string) => Promise<any>;
  llm_ping: (name: string) => Promise<any>;
  llm_close: (name: string) => Promise<any>;
}

export interface WASMClientOptions extends ClientOptions {
  /**
   * Path to the WASM module (.wasm file)
   * Default: './operrouter_core_wasm_bg.wasm'
   */
  wasmPath?: string;
}

export class WASMClient implements OperRouterClient {
  private wasm: WasmModule | null = null;
  private initPromise: Promise<void>;
  private httpEndpoint: string;

  constructor(httpEndpoint: string, options: WASMClientOptions = {}) {
    this.httpEndpoint = httpEndpoint;
    const wasmPath = options.wasmPath || './operrouter_core_wasm_bg.wasm';
    
    // Initialize WASM module asynchronously
    this.initPromise = this.loadWasm(wasmPath);
  }

  /**
   * Load and initialize the WASM module
   */
  private async loadWasm(wasmPath: string): Promise<void> {
    try {
      // Dynamic import of wasm-bindgen generated JS
      // Users need to copy operrouter-core-wasm/pkg to their project
      const wasmModule = await import(
        /* @vite-ignore */
        /* webpackIgnore: true */
        wasmPath.replace('.wasm', '.js')
      );
      
      // Initialize the WASM module
      await wasmModule.default(wasmPath);
      
      // Store the WASM exports
      this.wasm = wasmModule as unknown as WasmModule;
      
      // Configure HTTP endpoint in WASM
      this.wasm.set_http_endpoint(this.httpEndpoint);
      
      console.log('âœ… WASM module loaded:', this.wasm.version());
    } catch (error) {
      throw new Error(`Failed to load WASM module: ${error}`);
    }
  }

  /**
   * Ensure WASM is loaded before calling methods
   */
  private async ensureReady(): Promise<WasmModule> {
    await this.initPromise;
    if (!this.wasm) {
      throw new Error('WASM module not initialized');
    }
    return this.wasm;
  }

  // ==================== Core Methods ====================

  async ping(): Promise<PingResponse> {
    const wasm = await this.ensureReady();
    const result = wasm.ping();
    return {
      success: result === 'ok',
      message: result,
    };
  }

  async validateConfig(config: Record<string, any>): Promise<ConfigResponse> {
    const wasm = await this.ensureReady();
    
    // Convert JSON config to TOML format
    const toml = this.jsonToToml(config);
    const isValid = wasm.validate_config(toml);
    
    return {
      success: isValid,
      message: isValid ? 'Config is valid' : 'Config validation failed',
    };
  }

  async loadConfig(path: string): Promise<ConfigResponse> {
    // In browser, we need to fetch the file
    try {
      const response = await fetch(path);
      if (!response.ok) {
        return {
          success: false,
          message: `Failed to fetch config: ${response.statusText}`,
        };
      }
      
      const toml = await response.text();
      const wasm = await this.ensureReady();
      const isValid = wasm.validate_config(toml);
      
      return {
        success: isValid,
        message: isValid ? 'Config loaded and validated' : 'Config validation failed',
      };
    } catch (error) {
      return {
        success: false,
        message: `Failed to load config: ${error}`,
      };
    }
  }

  async getMetadata(): Promise<Metadata> {
    const wasm = await this.ensureReady();
    
    // For metadata, we need a config file. Use empty config for now.
    const emptyToml = `
[metadata]
name = "operrouter-wasm"
version = "${wasm.version()}"
description = "OperRouter WASM Client"
`;
    
    const metadataJson = wasm.get_metadata(emptyToml);
    const metadata = JSON.parse(metadataJson);
    
    return {
      name: metadata.name || 'operrouter-wasm',
      version: metadata.version || wasm.version(),
      description: metadata.description,
    };
  }

  // ==================== DataSource Methods ====================

  async createDataSource(
    name: string,
    config: DataSourceConfig
  ): Promise<DataSourceResponse> {
    const wasm = await this.ensureReady();
    
    // Convert config to WASM-compatible format (spread config to include all properties)
    const wasmConfig = { ...config };
    
    try {
      const result = await wasm.ds_create(name, wasmConfig);
      return {
        success: result.success || false,
        message: result.message || result.error || '',
      };
    } catch (error) {
      return {
        success: false,
        message: `${error}`,
      };
    }
  }

  async queryDataSource(
    name: string,
    query: string
  ): Promise<DataSourceQueryResponse> {
    const wasm = await this.ensureReady();
    
    try {
      const result = await wasm.ds_query(name, query);
      return {
        success: result.success || false,
        rows: result.rows || [],
        message: result.message || result.error || '',
      };
    } catch (error) {
      return {
        success: false,
        rows: [],
        message: `${error}`,
      };
    }
  }

  async executeDataSource(
    name: string,
    query: string
  ): Promise<DataSourceResponse> {
    const wasm = await this.ensureReady();
    
    try {
      const result = await wasm.ds_execute(name, query);
      return {
        success: result.success || false,
        message: result.message || result.error || '',
      };
    } catch (error) {
      return {
        success: false,
        message: `${error}`,
      };
    }
  }

  async insertDataSource(
    name: string,
    data: Record<string, any>
  ): Promise<DataSourceResponse> {
    const wasm = await this.ensureReady();
    
    try {
      const result = await wasm.ds_insert(name, data);
      return {
        success: result.success || false,
        message: result.message || result.error || '',
      };
    } catch (error) {
      return {
        success: false,
        message: `${error}`,
      };
    }
  }

  async pingDataSource(name: string): Promise<DataSourceResponse> {
    const wasm = await this.ensureReady();
    
    try {
      const result = await wasm.ds_ping(name);
      return {
        success: result.healthy || result.success || false,
        message: result.message || result.error || '',
      };
    } catch (error) {
      return {
        success: false,
        message: `${error}`,
      };
    }
  }

  async closeDataSource(name: string): Promise<DataSourceResponse> {
    const wasm = await this.ensureReady();
    
    try {
      const result = await wasm.ds_close(name);
      return {
        success: result.success || false,
        message: result.message || result.error || '',
      };
    } catch (error) {
      return {
        success: false,
        message: `${error}`,
      };
    }
  }

  // ==================== LLM Methods ====================

  async createLLM(name: string, config: LLMConfig): Promise<LLMResponse> {
    const wasm = await this.ensureReady();
    
    const wasmConfig = {
      provider: config.provider,
      model: config.model,
      api_key: config.api_key,
    };
    
    try {
      const result = await wasm.llm_create(name, wasmConfig);
      return {
        success: result.success || false,
        message: result.message || result.error || '',
      };
    } catch (error) {
      return {
        success: false,
        message: `${error}`,
      };
    }
  }

  async generateLLM(
    name: string,
    prompt: string
  ): Promise<LLMGenerateResponse> {
    const wasm = await this.ensureReady();
    
    try {
      const result = await wasm.llm_generate(name, prompt);
      return {
        success: result.success || false,
        text: result.text || '',
        message: result.message || result.error || '',
      };
    } catch (error) {
      return {
        success: false,
        text: '',
        message: `${error}`,
      };
    }
  }

  async chatLLM(
    name: string,
    messages: ChatMessage[]
  ): Promise<LLMChatResponse> {
    const wasm = await this.ensureReady();
    
    try {
      const result = await wasm.llm_chat(name, messages);
      return {
        success: result.success || false,
        text: result.text || '',
        message: result.message || result.error || '',
      };
    } catch (error) {
      return {
        success: false,
        text: '',
        message: `${error}`,
      };
    }
  }

  async embeddingLLM(
    name: string,
    text: string
  ): Promise<LLMEmbeddingResponse> {
    const wasm = await this.ensureReady();
    
    try {
      const result = await wasm.llm_embedding(name, text);
      return {
        success: result.success || false,
        embedding: result.embedding || [],
        message: result.message || result.error || '',
      };
    } catch (error) {
      return {
        success: false,
        embedding: [],
        message: `${error}`,
      };
    }
  }

  async pingLLM(name: string): Promise<LLMResponse> {
    const wasm = await this.ensureReady();
    
    try {
      const result = await wasm.llm_ping(name);
      return {
        success: result.healthy || result.success || false,
        message: result.message || result.error || '',
      };
    } catch (error) {
      return {
        success: false,
        message: `${error}`,
      };
    }
  }

  async closeLLM(name: string): Promise<LLMResponse> {
    const wasm = await this.ensureReady();
    
    try {
      const result = await wasm.llm_close(name);
      return {
        success: result.success || false,
        message: result.message || result.error || '',
      };
    } catch (error) {
      return {
        success: false,
        message: `${error}`,
      };
    }
  }

  // ==================== Helper Methods ====================

  /**
   * Simple JSON to TOML converter (basic implementation)
   */
  private jsonToToml(obj: Record<string, any>): string {
    const lines: string[] = [];
    
    for (const [key, value] of Object.entries(obj)) {
      if (typeof value === 'object' && value !== null && !Array.isArray(value)) {
        lines.push(`[${key}]`);
        for (const [subKey, subValue] of Object.entries(value)) {
          if (typeof subValue === 'string') {
            lines.push(`${subKey} = "${subValue}"`);
          } else {
            lines.push(`${subKey} = ${JSON.stringify(subValue)}`);
          }
        }
        lines.push('');
      }
    }
    
    return lines.join('\n');
  }
}
